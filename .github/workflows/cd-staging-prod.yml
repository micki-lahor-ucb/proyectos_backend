name: CD - Staging + Production

on:
  push:
    branches:
      - 'main'
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build:
    name: Build Artifact
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build backend
        run: npm run build

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Create RELEASE_ID
        run: |
          RELEASE_ID=$(date +%Y%m%d_%H%M%S)_${GITHUB_SHA:0:7}
          echo "$RELEASE_ID" > RELEASE_ID
          echo "RELEASE_ID=$RELEASE_ID" >> $GITHUB_ENV
          echo "Created RELEASE_ID: $RELEASE_ID"

      - name: Upload backend artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-release-${{ github.ref_name }}
          path: |
            dist
            node_modules
            package.json
            package-lock.json
            prisma
            RELEASE_ID

  deploy_staging:
    name: Deploy to Staging
    if: github.ref == 'refs/heads/main'
    runs-on: self-hosted  # Cambiar a ubuntu-latest si usas ngrok
    needs: [build]
    environment:
      name: staging
    steps:
      - uses: actions/checkout@v4

      - name: Download backend artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-release-${{ github.ref_name }}
          path: ./artifact

      - name: Read RELEASE_ID
        id: release
        shell: pwsh
        run: |
          $RELEASE_ID = Get-Content ./artifact/RELEASE_ID -Raw
          $RELEASE_ID = $RELEASE_ID.Trim()
          Add-Content -Path $env:GITHUB_OUTPUT -Value "RELEASE_ID=$RELEASE_ID"
          Write-Host "Deploying release: $RELEASE_ID"

      - name: Deploy backend to staging
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_USER: ${{ secrets.STAGING_USER }}
          STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
          STAGING_PORT: "2222"
        shell: pwsh
        run: |
          $sshDir = "$env:USERPROFILE\.ssh"
          if (-not (Test-Path $sshDir)) { New-Item -ItemType Directory -Path $sshDir -Force | Out-Null }
          
          # Normalize host/user (avoid values like "user@host" or "host:2222" in secrets)
          $remoteHost = ($env:STAGING_HOST ?? "").Trim()
          if ($remoteHost.Contains("@")) { $remoteHost = $remoteHost.Split("@")[-1] }
          if ($remoteHost.Contains(":")) { $remoteHost = $remoteHost.Split(":")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteHost)) { throw "STAGING_HOST is empty/invalid" }
          
          $remoteUser = ($env:STAGING_USER ?? "").Trim()
          if ($remoteUser.Contains("@")) { $remoteUser = $remoteUser.Split("@")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteUser)) { throw "STAGING_USER is empty/invalid" }
          
          $remote = "$remoteUser@$remoteHost"
          
          # Use an ephemeral known_hosts file per run (containers change host keys often)
          $knownHosts = Join-Path $sshDir "known_hosts_ci"
          if (Test-Path $knownHosts) { Remove-Item -Force $knownHosts }

          # Also scrub the default known_hosts to avoid "REMOTE HOST IDENTIFICATION HAS CHANGED"
          # (some ssh/scp builds may ignore UserKnownHostsFile options)
          & ssh-keygen -R "[$remoteHost]:$env:STAGING_PORT" 2>$null | Out-Null
          & ssh-keygen -R $remoteHost 2>$null | Out-Null
          
          # Save SSH key with proper format (no BOM, LF line endings)
          $keyContent = $env:STAGING_SSH_KEY
          $keyContent = $keyContent -replace "`r`n", "`n" -replace "`r", "`n"
          $keyContent = $keyContent.TrimEnd("`n", "`r") + "`n"
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          $bytes = $utf8NoBom.GetBytes($keyContent)
          [System.IO.File]::WriteAllBytes("$sshDir\deploy_key", $bytes)
          icacls "$sshDir\deploy_key" /inheritance:r /grant "$env:USERNAME`:F" | Out-Null
          
          $env:RELEASE = "${{ steps.release.outputs.RELEASE_ID }}"
          
          Write-Host "Creating release directory..."
          # Create release directory with timeout
          $sshArgs = @(
            "-i", "$sshDir\deploy_key",
            "-p", $env:STAGING_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            "-o", "ServerAliveInterval=5",
            "-o", "ServerAliveCountMax=3",
            $remote,
            "mkdir -p /var/www/project-management/releases/$env:RELEASE"
          )
          & ssh @sshArgs
          if ($LASTEXITCODE -ne 0) { throw "Failed to create release directory" }
          
          Write-Host "Copying files..."
          # Pack + copy a single file (much faster than recursive scp for node_modules)
          $archive = "artifact-$env:RELEASE.tgz"
          $remoteArchivePath = "/var/www/project-management/releases/$env:RELEASE/$archive"
          if (Test-Path $archive) { Remove-Item -Force $archive }
          & tar -czf $archive -C ./artifact .
          if ($LASTEXITCODE -ne 0) { throw "Failed to create tar.gz archive" }

          # Copy archive (single file)
          $scpArgs = @(
            "-i", "$sshDir\deploy_key",
            "-P", $env:STAGING_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            $archive
          )
          $scpTarget = "${remote}:/var/www/project-management/releases/$env:RELEASE/"
          & scp @scpArgs $scpTarget
          if ($LASTEXITCODE -ne 0) { throw "Failed to copy files" }
          
          Write-Host "Running migrations and switching symlink..."
          # Run a remote deploy script (avoid CRLF issues when piping from PowerShell)
          $deploySh = "deploy-$env:RELEASE.sh"
          $remoteDeploySh = "/var/www/project-management/releases/$env:RELEASE/$deploySh"
          $deployContent = @(
            'set -euo pipefail',
            "cd `"/var/www/project-management/releases/$env:RELEASE`"",
            "tar -xzf `"$archive`"",
            "rm -f `"$archive`"",
            'ln -sfn /var/www/project-management/shared/.env .env',
            '',
            'export NODE_ENV=staging',
            "export RELEASE_ID=`"$env:RELEASE`"",
            '',
            'echo "Node version:"',
            'node -v',
            'major=$(node -p "parseInt(process.versions.node.split(String.fromCharCode(46))[0],10)")',
            'if [ "$major" -lt 18 ]; then echo "Node >=18 required for Prisma" >&2; exit 1; fi',
            '# Ensure Prisma engine binaries are executable (tar created on Windows may lose +x bits)',
            'if [ -d "./node_modules/@prisma/engines" ]; then',
            '  chmod -R a+rX "./node_modules/@prisma/engines" || true',
            '  chmod +x ./node_modules/@prisma/engines/* 2>/dev/null || true',
            '  find "./node_modules/@prisma/engines" -type f -maxdepth 1 -exec chmod +x {} \; 2>/dev/null || true',
            'fi',
            'if [ -d "./node_modules/.prisma/client" ]; then',
            '  chmod -R a+rX "./node_modules/.prisma/client" || true',
            '  chmod +x ./node_modules/.prisma/client/*engine* 2>/dev/null || true',
            'fi',
            'if [ -d "./node_modules/.bin" ]; then chmod -R a+rx "./node_modules/.bin" 2>/dev/null || true; fi',
            'if [ -f "./node_modules/prisma/build/index.js" ]; then',
            '  node ./node_modules/prisma/build/index.js migrate deploy',
            'else',
            '  echo "Prisma package not found in node_modules (node_modules/prisma/build/index.js missing)" >&2',
            '  exit 1',
            'fi',
            '',
            "ln -sfn `"/var/www/project-management/releases/$env:RELEASE`" /var/www/project-management/current",
            '',
            '# Start/restart app without global installs (no pm2)',
            'mkdir -p /var/www/project-management/shared/logs /var/www/project-management/shared/run',
            'PIDFILE=/var/www/project-management/shared/run/api.pid',
            'if [ -f "$PIDFILE" ] && kill -0 "$(cat "$PIDFILE")" 2>/dev/null; then',
            '  echo "Stopping previous process $(cat "$PIDFILE")"',
            '  kill "$(cat "$PIDFILE")" || true',
            '  sleep 1',
            'fi',
            'cd /var/www/project-management/current',
            'if [ -f ".env" ]; then set -a; . ./.env; set +a; fi',
            'export NODE_ENV=staging',
            "export RELEASE_ID=`"$env:RELEASE`"",
            '# Detect Nest entrypoint (dist/main.js vs dist/src/main.js)',
            'ENTRY="dist/main.js"',
            'if [ -f "dist/src/main.js" ]; then ENTRY="dist/src/main.js"; fi',
            'if [ ! -f "$ENTRY" ]; then echo "Entry file not found: $ENTRY" >&2; ls -la dist dist/src || true; exit 1; fi',
            'nohup node "$ENTRY" > /var/www/project-management/shared/logs/out.log 2> /var/www/project-management/shared/logs/error.log &',
            'echo $! > "$PIDFILE"',
            'echo "Started API with PID $(cat "$PIDFILE")"'
          ) -join "`n"
          $deployContent += "`n"
          # Ensure LF endings and no BOM
          $deployContent = $deployContent -replace "`r`n", "`n" -replace "`r", "`n"
          $utf8NoBom2 = New-Object System.Text.UTF8Encoding $false
          [System.IO.File]::WriteAllBytes($deploySh, $utf8NoBom2.GetBytes($deployContent))

          # Copy deploy script
          $scpScriptArgs = @(
            "-i", "$sshDir\deploy_key",
            "-P", $env:STAGING_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            $deploySh
          )
          & scp @scpScriptArgs "${remote}:/var/www/project-management/releases/$env:RELEASE/"
          if ($LASTEXITCODE -ne 0) { throw "Failed to copy deploy script" }

          # Execute deploy script remotely
          $sshRunArgs = @(
            "-i", "$sshDir\deploy_key",
            "-p", $env:STAGING_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            "-o", "ServerAliveInterval=5",
            "-o", "ServerAliveCountMax=3",
            $remote,
            "bash $remoteDeploySh"
          )
          & ssh @sshRunArgs
          if ($LASTEXITCODE -ne 0) { throw "Failed to deploy" }
          Remove-Item -Force $deploySh -ErrorAction SilentlyContinue
          
          Write-Host "Deployment completed successfully"

      - name: Health check staging
        env:
          STAGING_APP_URL: ${{ secrets.STAGING_APP_URL }}
        shell: pwsh
        run: |
          Start-Sleep -Seconds 5
          $base = ($env:STAGING_APP_URL ?? "").TrimEnd("/")
          if ($base.EndsWith("/api")) {
            $url = "$base/health"
          } else {
            $url = "$base/api/health"
          }
          Write-Host "Health check URL: $url"
          $response = Invoke-WebRequest -Uri $url -UseBasicParsing
          if ($response.StatusCode -ne 200) { exit 1 }

  rollback_staging:
    name: Rollback Staging
    if: failure() && github.ref == 'refs/heads/main'
    runs-on: self-hosted  # Cambiar a ubuntu-latest si usas ngrok
    needs: [deploy_staging]
    environment:
      name: staging
    steps:
      - name: Rollback to previous release
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_USER: ${{ secrets.STAGING_USER }}
          STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
          STAGING_PORT: "2222"
        shell: pwsh
        run: |
          $sshDir = "$env:USERPROFILE\.ssh"
          if (-not (Test-Path $sshDir)) { New-Item -ItemType Directory -Path $sshDir -Force | Out-Null }
          
          $remoteHost = ($env:STAGING_HOST ?? "").Trim()
          if ($remoteHost.Contains("@")) { $remoteHost = $remoteHost.Split("@")[-1] }
          if ($remoteHost.Contains(":")) { $remoteHost = $remoteHost.Split(":")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteHost)) { throw "STAGING_HOST is empty/invalid" }
          
          $remoteUser = ($env:STAGING_USER ?? "").Trim()
          if ($remoteUser.Contains("@")) { $remoteUser = $remoteUser.Split("@")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteUser)) { throw "STAGING_USER is empty/invalid" }
          
          $remote = "$remoteUser@$remoteHost"
          $knownHosts = Join-Path $sshDir "known_hosts_ci"
          if (Test-Path $knownHosts) { Remove-Item -Force $knownHosts }

          & ssh-keygen -R "[$remoteHost]:$env:STAGING_PORT" 2>$null | Out-Null
          & ssh-keygen -R $remoteHost 2>$null | Out-Null
          
          # Save SSH key with proper format (no BOM, LF line endings)
          $keyContent = $env:STAGING_SSH_KEY
          $keyContent = $keyContent -replace "`r`n", "`n" -replace "`r", "`n"
          $keyContent = $keyContent.TrimEnd("`n", "`r") + "`n"
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          $bytes = $utf8NoBom.GetBytes($keyContent)
          [System.IO.File]::WriteAllBytes("$sshDir\deploy_key", $bytes)
          icacls "$sshDir\deploy_key" /inheritance:r /grant "$env:USERNAME`:F" | Out-Null
          
          # Execute rollback remotely (avoid piping CRLF)
          $rollbackCmd = "bash -lc 'set -euo pipefail; PREV=$(ls -1dt /var/www/project-management/releases/*/ 2>/dev/null | sed -n \"2p\" | tr -d \"/\"); if [ -n \"$PREV\" ]; then echo \"Rolling back to: $PREV\"; ln -sfn \"$PREV\" /var/www/project-management/current; mkdir -p /var/www/project-management/shared/logs /var/www/project-management/shared/run; PIDFILE=/var/www/project-management/shared/run/api.pid; if [ -f \"$PIDFILE\" ] && kill -0 \"$(cat \"$PIDFILE\")\" 2>/dev/null; then kill \"$(cat \"$PIDFILE\")\" || true; sleep 1; fi; cd /var/www/project-management/current; if [ -f .env ]; then set -a; . ./.env; set +a; fi; export NODE_ENV=staging; CUR=$(readlink -f /var/www/project-management/current); export RELEASE_ID=$(basename \"$CUR\"); ENTRY=dist/main.js; [ -f dist/src/main.js ] && ENTRY=dist/src/main.js; [ -f \"$ENTRY\" ] || { echo \"Entry not found: $ENTRY\" >&2; ls -la dist dist/src || true; exit 1; }; nohup node \"$ENTRY\" > /var/www/project-management/shared/logs/out.log 2> /var/www/project-management/shared/logs/error.log & echo $! > \"$PIDFILE\"; echo \"Rollback started PID $(cat \"$PIDFILE\")\"; else echo \"No previous release found for rollback\"; exit 1; fi'"
          & ssh -i "$sshDir\deploy_key" -p $env:STAGING_PORT -o StrictHostKeyChecking=no -o "UserKnownHostsFile=$knownHosts" -o "GlobalKnownHostsFile=$knownHosts" -o BatchMode=yes -o IdentitiesOnly=yes -o PreferredAuthentications=publickey -o ConnectTimeout=10 -o ServerAliveInterval=5 -o ServerAliveCountMax=3 $remote $rollbackCmd

  deploy_production:
    name: Deploy to Production
    if: startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    runs-on: self-hosted  # Cambiar a ubuntu-latest si usas ngrok
    needs: [build]
    environment:
      name: production
    steps:
      - uses: actions/checkout@v4

      - name: Download backend artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-release-${{ github.ref_name }}
          path: ./artifact

      - name: Read RELEASE_ID
        id: release
        shell: pwsh
        run: |
          $RELEASE_ID = Get-Content ./artifact/RELEASE_ID -Raw
          $RELEASE_ID = $RELEASE_ID.Trim()
          Add-Content -Path $env:GITHUB_OUTPUT -Value "RELEASE_ID=$RELEASE_ID"
          Write-Host "Deploying release: $RELEASE_ID"

      - name: Deploy backend to production
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_USER: ${{ secrets.PROD_USER }}
          PROD_SSH_KEY: ${{ secrets.PROD_SSH_KEY }}
          PROD_PORT: "2223"
        shell: pwsh
        run: |
          $sshDir = "$env:USERPROFILE\.ssh"
          if (-not (Test-Path $sshDir)) { New-Item -ItemType Directory -Path $sshDir -Force | Out-Null }
          
          $remoteHost = ($env:PROD_HOST ?? "").Trim()
          if ($remoteHost.Contains("@")) { $remoteHost = $remoteHost.Split("@")[-1] }
          if ($remoteHost.Contains(":")) { $remoteHost = $remoteHost.Split(":")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteHost)) { throw "PROD_HOST is empty/invalid" }
          
          $remoteUser = ($env:PROD_USER ?? "").Trim()
          if ($remoteUser.Contains("@")) { $remoteUser = $remoteUser.Split("@")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteUser)) { throw "PROD_USER is empty/invalid" }
          
          $remote = "$remoteUser@$remoteHost"
          $knownHosts = Join-Path $sshDir "known_hosts_ci"
          if (Test-Path $knownHosts) { Remove-Item -Force $knownHosts }
          & ssh-keygen -R "[$remoteHost]:$env:PROD_PORT" 2>$null | Out-Null
          & ssh-keygen -R $remoteHost 2>$null | Out-Null
          
          # Save SSH key with proper format (no BOM, LF line endings)
          $keyContent = $env:PROD_SSH_KEY
          $keyContent = $keyContent -replace "`r`n", "`n" -replace "`r", "`n"
          $keyContent = $keyContent.TrimEnd("`n", "`r") + "`n"
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          $bytes = $utf8NoBom.GetBytes($keyContent)
          [System.IO.File]::WriteAllBytes("$sshDir\deploy_key", $bytes)
          icacls "$sshDir\deploy_key" /inheritance:r /grant "$env:USERNAME`:F" | Out-Null
          
          $env:RELEASE = "${{ steps.release.outputs.RELEASE_ID }}"
          
          Write-Host "Creating release directory..."
          # Create release directory with timeout
          $sshArgs = @(
            "-i", "$sshDir\deploy_key",
            "-p", $env:PROD_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            "-o", "ServerAliveInterval=5",
            "-o", "ServerAliveCountMax=3",
            $remote,
            "mkdir -p /var/www/project-management/releases/$env:RELEASE"
          )
          & ssh @sshArgs
          if ($LASTEXITCODE -ne 0) { throw "Failed to create release directory" }
          
          Write-Host "Copying files..."
          # Pack + copy a single file (much faster than recursive scp for node_modules)
          $archive = "artifact-$env:RELEASE.tgz"
          $remoteArchivePath = "/var/www/project-management/releases/$env:RELEASE/$archive"
          if (Test-Path $archive) { Remove-Item -Force $archive }
          & tar -czf $archive -C ./artifact .
          if ($LASTEXITCODE -ne 0) { throw "Failed to create tar.gz archive" }

          # Copy archive (single file)
          $scpArgs = @(
            "-i", "$sshDir\deploy_key",
            "-P", $env:PROD_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            $archive
          )
          $scpTarget = "${remote}:/var/www/project-management/releases/$env:RELEASE/"
          & scp @scpArgs $scpTarget
          if ($LASTEXITCODE -ne 0) { throw "Failed to copy files" }
          
          Write-Host "Running migrations and switching symlink..."
          # Run a remote deploy script (avoid CRLF issues when piping from PowerShell)
          $deploySh = "deploy-$env:RELEASE.sh"
          $remoteDeploySh = "/var/www/project-management/releases/$env:RELEASE/$deploySh"
          $deployContent = @(
            'set -euo pipefail',
            "cd `"/var/www/project-management/releases/$env:RELEASE`"",
            "tar -xzf `"$archive`"",
            "rm -f `"$archive`"",
            'ln -sfn /var/www/project-management/shared/.env .env',
            '',
            'export NODE_ENV=production',
            "export RELEASE_ID=`"$env:RELEASE`"",
            '',
            'echo "Node version:"',
            'node -v',
            'major=$(node -p "parseInt(process.versions.node.split(String.fromCharCode(46))[0],10)")',
            'if [ "$major" -lt 18 ]; then echo "Node >=18 required for Prisma" >&2; exit 1; fi',
            '# Ensure Prisma engine binaries are executable (tar created on Windows may lose +x bits)',
            'if [ -d "./node_modules/@prisma/engines" ]; then',
            '  chmod -R a+rX "./node_modules/@prisma/engines" || true',
            '  chmod +x ./node_modules/@prisma/engines/* 2>/dev/null || true',
            '  find "./node_modules/@prisma/engines" -maxdepth 1 -type f -exec chmod +x {} \\; 2>/dev/null || true',
            'fi',
            'if [ -d "./node_modules/.prisma/client" ]; then',
            '  chmod -R a+rX "./node_modules/.prisma/client" || true',
            '  chmod +x ./node_modules/.prisma/client/*engine* 2>/dev/null || true',
            'fi',
            'if [ -d "./node_modules/.bin" ]; then chmod -R a+rx "./node_modules/.bin" 2>/dev/null || true; fi',
            'if [ -f "./node_modules/prisma/build/index.js" ]; then',
            '  node ./node_modules/prisma/build/index.js migrate deploy',
            'else',
            '  echo "Prisma package not found in node_modules (node_modules/prisma/build/index.js missing)" >&2',
            '  exit 1',
            'fi',
            '',
            "ln -sfn `"/var/www/project-management/releases/$env:RELEASE`" /var/www/project-management/current",
            '',
            '# Start/restart app without global installs (no pm2)',
            'mkdir -p /var/www/project-management/shared/logs /var/www/project-management/shared/run',
            'PIDFILE=/var/www/project-management/shared/run/api.pid',
            'if [ -f "$PIDFILE" ] && kill -0 "$(cat "$PIDFILE")" 2>/dev/null; then',
            '  echo "Stopping previous process $(cat "$PIDFILE")"',
            '  kill "$(cat "$PIDFILE")" || true',
            '  sleep 1',
            'fi',
            'cd /var/www/project-management/current',
            'if [ -f ".env" ]; then set -a; . ./.env; set +a; fi',
            'export NODE_ENV=production',
            "export RELEASE_ID=`"$env:RELEASE`"",
            '# Detect Nest entrypoint (dist/main.js vs dist/src/main.js)',
            'ENTRY="dist/main.js"',
            'if [ -f "dist/src/main.js" ]; then ENTRY="dist/src/main.js"; fi',
            'if [ ! -f "$ENTRY" ]; then echo "Entry file not found: $ENTRY" >&2; ls -la dist dist/src || true; exit 1; fi',
            'nohup node "$ENTRY" > /var/www/project-management/shared/logs/out.log 2> /var/www/project-management/shared/logs/error.log &',
            'echo $! > "$PIDFILE"',
            'echo "Started API with PID $(cat "$PIDFILE")"'
          ) -join "`n"
          $deployContent += "`n"
          # Ensure LF endings and no BOM
          $deployContent = $deployContent -replace "`r`n", "`n" -replace "`r", "`n"
          $utf8NoBom2 = New-Object System.Text.UTF8Encoding $false
          [System.IO.File]::WriteAllBytes($deploySh, $utf8NoBom2.GetBytes($deployContent))

          # Copy deploy script
          $scpScriptArgs = @(
            "-i", "$sshDir\deploy_key",
            "-P", $env:PROD_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            $deploySh
          )
          & scp @scpScriptArgs "${remote}:/var/www/project-management/releases/$env:RELEASE/"
          if ($LASTEXITCODE -ne 0) { throw "Failed to copy deploy script" }

          # Execute deploy script remotely
          $sshRunArgs = @(
            "-i", "$sshDir\deploy_key",
            "-p", $env:PROD_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            "-o", "ServerAliveInterval=5",
            "-o", "ServerAliveCountMax=3",
            $remote,
            "bash $remoteDeploySh"
          )
          & ssh @sshRunArgs
          if ($LASTEXITCODE -ne 0) { throw "Failed to deploy" }
          Remove-Item -Force $deploySh -ErrorAction SilentlyContinue
          
          Write-Host "Deployment completed successfully"

      - name: Health check production
        env:
          PROD_APP_URL: ${{ secrets.PROD_APP_URL }}
        shell: pwsh
        run: |
          Start-Sleep -Seconds 5
          $base = ($env:PROD_APP_URL ?? "").TrimEnd("/")
          if ($base.EndsWith("/api")) {
            $url = "$base/health"
          } else {
            $url = "$base/api/health"
          }
          Write-Host "Health check URL: $url"
          $response = Invoke-WebRequest -Uri $url -UseBasicParsing
          if ($response.StatusCode -ne 200) { exit 1 }

  rollback_production:
    name: Rollback Production
    if: failure() && (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    runs-on: self-hosted  # Cambiar a ubuntu-latest si usas ngrok
    needs: [deploy_production]
    environment:
      name: production
    steps:
      - name: Rollback to previous release
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_USER: ${{ secrets.PROD_USER }}
          PROD_SSH_KEY: ${{ secrets.PROD_SSH_KEY }}
          PROD_PORT: "2223"
        shell: pwsh
        run: |
          $sshDir = "$env:USERPROFILE\.ssh"
          if (-not (Test-Path $sshDir)) { New-Item -ItemType Directory -Path $sshDir -Force | Out-Null }
          
          $remoteHost = ($env:PROD_HOST ?? "").Trim()
          if ($remoteHost.Contains("@")) { $remoteHost = $remoteHost.Split("@")[-1] }
          if ($remoteHost.Contains(":")) { $remoteHost = $remoteHost.Split(":")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteHost)) { throw "PROD_HOST is empty/invalid" }
          
          $remoteUser = ($env:PROD_USER ?? "").Trim()
          if ($remoteUser.Contains("@")) { $remoteUser = $remoteUser.Split("@")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteUser)) { throw "PROD_USER is empty/invalid" }
          
          $remote = "$remoteUser@$remoteHost"
          
          # Save SSH key with proper format (no BOM, LF line endings)
          $keyContent = $env:PROD_SSH_KEY
          $keyContent = $keyContent -replace "`r`n", "`n" -replace "`r", "`n"
          $keyContent = $keyContent.TrimEnd("`n", "`r") + "`n"
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          $bytes = $utf8NoBom.GetBytes($keyContent)
          [System.IO.File]::WriteAllBytes("$sshDir\deploy_key", $bytes)
          icacls "$sshDir\deploy_key" /inheritance:r /grant "$env:USERNAME`:F" | Out-Null
          
          # Execute rollback remotely (avoid piping CRLF)
          $rollbackCmd = "bash -lc 'set -euo pipefail; PREV=$(ls -1dt /var/www/project-management/releases/*/ 2>/dev/null | sed -n \"2p\" | tr -d \"/\"); if [ -n \"$PREV\" ]; then echo \"Rolling back to: $PREV\"; ln -sfn \"$PREV\" /var/www/project-management/current; mkdir -p /var/www/project-management/shared/logs /var/www/project-management/shared/run; PIDFILE=/var/www/project-management/shared/run/api.pid; if [ -f \"$PIDFILE\" ] && kill -0 \"$(cat \"$PIDFILE\")\" 2>/dev/null; then kill \"$(cat \"$PIDFILE\")\" || true; sleep 1; fi; cd /var/www/project-management/current; if [ -f .env ]; then set -a; . ./.env; set +a; fi; export NODE_ENV=production; CUR=$(readlink -f /var/www/project-management/current); export RELEASE_ID=$(basename \"$CUR\"); ENTRY=dist/main.js; [ -f dist/src/main.js ] && ENTRY=dist/src/main.js; [ -f \"$ENTRY\" ] || { echo \"Entry not found: $ENTRY\" >&2; ls -la dist dist/src || true; exit 1; }; nohup node \"$ENTRY\" > /var/www/project-management/shared/logs/out.log 2> /var/www/project-management/shared/logs/error.log & echo $! > \"$PIDFILE\"; echo \"Rollback started PID $(cat \"$PIDFILE\")\"; else echo \"No previous release found for rollback\"; exit 1; fi'"
          & ssh -i "$sshDir\deploy_key" -p $env:PROD_PORT -o StrictHostKeyChecking=no -o "UserKnownHostsFile=$knownHosts" -o "GlobalKnownHostsFile=$knownHosts" -o BatchMode=yes -o IdentitiesOnly=yes -o PreferredAuthentications=publickey -o ConnectTimeout=10 -o ServerAliveInterval=5 -o ServerAliveCountMax=3 $remote $rollbackCmd
